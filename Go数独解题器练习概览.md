# Go数独解题器练习

# 基础部分（非并发，顺序执行）

## 文件结构

- root
    - newSudoku（实现部分）
        - action.go  // 行为函数文件
        - config.go  // 结构体与配置
        - init.go   // 初始化函数文件
    - cmd（main）
        - newSudoku
            - newSudoku.go // 执行入口文件
    - go.mod

## 结构体定义

### 节点 node

节点定义为九宫格中的每一个格子，作为解题器，必然是有输入的题，因此需要把题目中提供的已有数字节点锁定。而可能选项则是为了复杂数独（无法通过唯一选择解题）中存在的猜测与回溯行为而设置的。

因此节点定义如下

```go
type node struct {
	num       uint8
	posi      []uint8
	changable bool
}
```

### 步 step

步定义为每对一个节点进行填写操作的记录，它在简单数独中无法发挥作用，只有在需要回溯时才能产生作用，因此对外可不显露。

步定义如下

```go
type step struct {
	id    int
	x     int
	y     int
	value uint8
}
```

### 桌子 TablePlace

桌子是对外暴露的唯一数据类型，它囊括了所有解题中需要使用的数据。相当于最底层的类。

在Go中，开头字母大写的类型、对象、函数为公共类型，即可在不同package中调用到，这里Blank作为公共是因为在入口函数中需要判断何时停止循环计算。

定义如下

```go
type TablePlace struct {
	table        [9][9]node
	stepList     []step
	Blank        int
	minPosiStep  step
}
```

## 方法实现

九宫格题目的输入采用主函数中输入的方法（暂时），为9*9的uint8类型二维数组，判断输入是否为0决定table中的节点是否为可修改以及该位置的初始值为多少，并在写入过程中记录所有空白节点的数量。

采用较为简单的循环方式而不是递归方式进行演进，能减少对于内存的占用，进入错误分支后回溯的实现也较为简单。

单步演进中，遍历所有值为0的空节点，找出该节点的可能数值列表，如果唯一，则写入；不唯一则记录并与当前最小可能步进行比较，记录本轮演进中出现的最小可能步长。如果最小可能步长大于1，则进行一次猜测，取最小步长节点的可能数值中的第一个作为它的值，进入下一次演进。

当演进出现节点为0但可能数值列为空时，则进行回溯，回溯到最近的一次猜测并进入另一猜测分支，实现深度优先搜索策略。

### 问题

1. 如果存在多种答案的数独，这种深度优先的策略只能找到一个答案。（理论上说数独只有一个答案）
2. 深度优先效率较低，并不能体现出go语言天生适合并发的优势。（深度优先搜索用时约95-105ms，多线程广度搜索实现后仅用时22ms）

因此在原有代码基础上进行改进，使用go关键字对可并行部分进行操作，取消回溯改用传值操作。(详见sudoku-goroutine分支)